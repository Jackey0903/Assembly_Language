# Pong 双人对战游戏 - 项目说明文档

**2351493 胡浩杰**

## 一、项目概述

### 1.1 项目名称
**Pong 双人对战游戏**（基于8086汇编语言的文本模式实现）

![2](./2.png)

![3](./3.png)

![1](./1.png)



### 1.2 开发环境

- **汇编器**: MASM 5.0 (Microsoft Macro Assembler)
- **链接器**: Microsoft Overlay Linker 3.60
- **运行环境**: DOSBox 0.74-3 (macOS/Windows/Linux)
- **开发平台**: macOS
- **调试工具**: DOSBox内置调试器

### 1.3 项目功能
本项目实现了经典的Pong乒乓球游戏,主要功能包括:
- 双人实时对战
- 球拍上下移动控制
- 球与墙壁/球拍的碰撞检测
- 实时计分系统
- 先得3分者获胜
- 游戏速度可调节

---

## 二、核心功能实现

### 2.1 游戏逻辑架构

#### 2.1.1 程序整体结构
程序采用经典的**事件循环**架构,分为三个主要阶段:

1. **初始化阶段**
   - 设置数据段寄存器(DS)
   - 初始化视频模式(80×25文本模式)
   - 隐藏光标
   - 显示游戏标题和控制说明
   - 等待玩家按键开始

2. **游戏循环阶段**
   ```
   game_loop:
       ├─ check_input()     // 检查键盘输入,更新球拍位置
       ├─ update_ball()     // 更新球位置,碰撞检测,得分判定
       ├─ draw_game()       // 清屏并重绘所有游戏元素
       ├─ delay()           // 延时控制帧率
       └─ 检查获胜条件 → 继续循环或结束游戏
   ```

3. **游戏结束阶段**
   - 显示获胜者信息
   - 等待玩家按键
   - 恢复屏幕和光标
   - 返回DOS

#### 2.1.2 数据结构设计

**内存布局** (数据段.data):
```
偏移地址    变量名          类型    说明
-------------------------------------------
+0000h     field_width     DB      场地宽度(78)
+0001h     field_height    DB      场地高度(23)
+0002h     ball_x          DB      球X坐标(0-79)
+0003h     ball_y          DB      球Y坐标(0-24)
+0004h     ball_dx         DB      球X速度(±1)
+0005h     ball_dy         DB      球Y速度(±1)
+0006h     p1_x            DB      玩家1 X坐标(2)
+0007h     p1_y            DB      玩家1 Y坐标(可变)
+0008h     p1_height       DB      玩家1球拍高度(5)
+0009h     p1_score        DB      玩家1分数(0-3)
+000Ah     p2_x            DB      玩家2 X坐标(77)
+000Bh     p2_y            DB      玩家2 Y坐标(可变)
+000Ch     p2_height       DB      玩家2球拍高度(5)
+000Dh     p2_score        DB      玩家2分数(0-3)
+000Eh     win_score       DB      获胜分数(3)
+000Fh     game_speed      DW      游戏速度(15000)
...
```

**坐标系统**:
```
(0,0)                    (79,0)
  ┌─────────────────────────┐
  │ 标题栏                  │ 第0行
  ├─────────────────────────┤
  │     分数: 0:0          │ 第1行
  ├─────────────────────────┤
  │█                       █│ 
  │█        O              █│ 游戏区域
  │█                       █│ (2-23行)
  │                         │
(0,24)                  (79,24)
```

#### 2.1.3 子程序调用关系图
```
main
 ├─ set_cursor          (设置光标位置)
 ├─ game_loop
 │   ├─ check_input
 │   │   └─ game_end    (ESC退出)
 │   ├─ update_ball
 │   │   ├─ reset_ball  (得分后重置)
 │   │   └─ 碰撞检测逻辑
 │   ├─ draw_game
 │   │   ├─ clear_screen_fast
 │   │   ├─ set_cursor  (多次调用)
 │   │   └─ print_char  (多次调用)
 │   └─ delay
 ├─ show_win_msg
 │   ├─ clear_screen_fast
 │   └─ set_cursor
 └─ game_end
```

### 2.2 关键算法实现

#### 2.2.1 碰撞检测算法

碰撞检测是游戏的核心算法,采用**轴对齐包围盒(AABB)**检测方法。

**算法流程图**:
```
update_ball开始
    ↓
更新球坐标: ball_x += ball_dx, ball_y += ball_dy
    ↓
检查Y轴碰撞(上下墙壁)
    ├─ 碰到? → 反转ball_dy
    └─ 未碰到 → 继续
    ↓
检查球是否在玩家1区域(X ≤ 3)?
    ├─ 是 → 检查Y坐标是否在球拍范围内?
    │       ├─ 是 → 反弹(ball_dx = 1)
    │       └─ 否 → 检查得分
    └─ 否 → 继续
    ↓
检查球是否在玩家2区域(X ≥ 76)?
    ├─ 是 → 检查Y坐标是否在球拍范围内?
    │       ├─ 是 → 反弹(ball_dx = -1)
    │       └─ 否 → 检查得分
    └─ 否 → 继续
    ↓
检查得分
    ├─ X ≤ 0 → 玩家2得分
    ├─ X ≥ 79 → 玩家1得分
    └─ 其他 → 继续游戏
    ↓
返回game_loop
```

**墙壁碰撞** (Y轴边界检测):
```assembly
; Y轴碰撞检测(上下墙壁)
cmp ball_y, 2           ; 检查是否碰到顶部
jle bounce_y            ; 碰到则反弹
cmp ball_y, 23          ; 检查是否碰到底部
jge bounce_y            ; 碰到则反弹

bounce_y:
    neg ball_dy         ; 反转Y方向速度
```

**球拍碰撞** (AABB矩形碰撞检测):
```assembly
; === 玩家1碰撞检测 ===
; 步骤1: X轴粗检测
cmp ball_x, 3           ; 球X坐标是否 ≤ 3?
jg check_p2_logic       ; 不在玩家1区域,检查玩家2

cmp ball_x, 1           ; 球X坐标是否 ≥ 1?
jl check_scoring        ; 球已越过球拍,检查得分

; 步骤2: Y轴精确检测(检查球是否在球拍高度范围内)
mov al, ball_y          ; AL = 球的Y坐标
cmp al, p1_y            ; 球Y < 球拍顶部?
jl check_scoring        ; 是,未击中

mov bl, p1_y            ; BL = 球拍Y坐标
add bl, p1_height       ; BL = 球拍底部Y坐标(顶部+高度)
cmp al, bl              ; 球Y > 球拍底部?
jg check_scoring        ; 是,未击中

; 步骤3: 碰撞确认,执行反弹
mov ball_dx, 1          ; 设置球向右移动
jmp update_done         ; 完成,返回

; === 玩家2碰撞检测 ===
; (逻辑相同,X坐标检测范围为76-78,反弹方向相反)
```

**碰撞检测数学模型**:
```
设球坐标为 (bx, by)
设球拍为矩形: 左上角(px, py), 宽度=1, 高度=h

碰撞条件(同时满足):
1. X轴重叠: px ≤ bx ≤ px+1
2. Y轴重叠: py ≤ by ≤ py+h

示例(玩家1):
  px=2, py=10, h=5
  球拍Y范围: [10, 15)
  
  若 ball_x=2 且 ball_y=12
  → X轴: 2 ≤ 2 ≤ 3 ✓
  → Y轴: 10 ≤ 12 ≤ 15 ✓
  → 碰撞发生!
```

#### 2.2.2 得分判定算法

**得分判定逻辑**:
```assembly
check_scoring:
    ; 检查左侧出界(玩家1失分,玩家2得分)
    cmp ball_x, 0       ; 球X坐标 ≤ 0?
    jle p2_scores       ; 是,玩家2得分

    ; 检查右侧出界(玩家2失分,玩家1得分)
    cmp ball_x, 79      ; 球X坐标 ≥ 79?
    jge p1_scores       ; 是,玩家1得分
    
    jmp update_done     ; 球未出界,继续游戏

p1_scores:
    inc p1_score        ; 玩家1分数+1
    call reset_ball     ; 重置球到中央
    jmp update_done

p2_scores:
    inc p2_score        ; 玩家2分数+1
    call reset_ball     ; 重置球到中央
    ; 继续执行update_done

update_done:
    ret                 ; 返回主循环
```

**重置球机制**:
```assembly
reset_ball proc
    mov ball_x, 40      ; 重置到场地中央X
    mov ball_y, 12      ; 重置到场地中央Y
    neg ball_dx         ; 反转X速度(向失分方发球)
    ; ball_dy保持不变(保留原Y方向)
    ret
reset_ball endp
```

**获胜判定** (在主循环中):
```assembly
; 每帧检查是否有玩家达到获胜分数
mov al, p1_score
cmp al, win_score       ; 玩家1分数 = 3?
je p1_wins              ; 是,玩家1获胜

mov al, p2_score
cmp al, win_score       ; 玩家2分数 = 3?
je p2_wins              ; 是,玩家2获胜

jmp game_loop           ; 否,继续游戏
```

#### 2.2.3 键盘输入处理

采用**非阻塞式**键盘检测,避免游戏卡顿。

**技术要点**:
- 使用INT 16h功能01h(**检查**缓冲区)而非功能00h(**等待**输入)
- 若无按键,ZF标志位=1,立即返回,不阻塞游戏循环
- 若有按键,用功能00h读取并清除缓冲区

**完整算法流程**:
```assembly
check_input proc
    push ax                 ; 保存寄存器

    ; === 步骤1: 非阻塞检查键盘缓冲区 ===
    mov ah, 01h             ; INT 16h功能01h
    int 16h                 ; ZF=0(有按键), ZF=1(无按键)
    jz input_done           ; 无按键,直接返回

    ; === 步骤2: 读取按键(清除缓冲区) ===
    mov ah, 00h             ; INT 16h功能00h
    int 16h                 ; AL=ASCII码, AH=扫描码

    ; === 步骤3: 特殊键处理 ===
    cmp al, 27              ; ESC键(ASCII 27)?
    je exit_game            ; 退出游戏

    ; === 步骤4: 大小写统一转换 ===
    or al, 20h              ; 将第5位置1(ASCII大写→小写)
                            ; 'W'(01010111) → 'w'(01110111)
                            ; 'S'(01010011) → 's'(01110011)

    ; === 步骤5: 按键匹配与响应 ===
    cmp al, 'w'
    je p1_up                ; W键→玩家1向上
    cmp al, 's'
    je p1_down              ; S键→玩家1向下
    cmp al, 'i'
    je p2_up                ; I键→玩家2向上
    cmp al, 'k'
    je p2_down              ; K键→玩家2向下
    
    jmp input_done          ; 其他键,忽略

; === 步骤6: 球拍移动处理(带边界检查) ===
p1_up:
    cmp p1_y, 2             ; Y坐标 ≤ 2(上边界)?
    jle input_done          ; 是,不移动
    dec p1_y                ; Y坐标-1(向上)
    jmp input_done

p1_down:
    mov al, p1_y
    add al, p1_height       ; AL = 球拍底部Y坐标
    cmp al, field_height    ; 底部 ≥ 场地高度?
    jge input_done          ; 是,不移动
    inc p1_y                ; Y坐标+1(向下)
    jmp input_done

; (玩家2逻辑相同)

input_done:
    pop ax                  ; 恢复寄存器
    ret
check_input endp
```

**边界检查示例**:
```
场地高度 = 23
球拍高度 = 5

向上移动限制:
  p1_y ≥ 2 (保留标题栏空间)

向下移动限制:
  p1_y + p1_height ≤ 23
  即 p1_y ≤ 18

有效移动范围: Y ∈ [2, 18]
```

### 2.3 显示系统实现

#### 2.3.1 文本模式绘图
使用**BIOS INT 10h**视频服务实现字符绘制:
```assembly
; 设置光标位置
set_cursor proc
    mov ah, 2           ; 功能02h: 设置光标
    mov bh, 0           ; 页号0
    ; DH=行, DL=列
    int 10h
    ret
set_cursor endp

; 打印字符
print_char proc
    mov ah, 0Eh         ; 功能0Eh: TTY字符输出
    mov bh, 0           ; 页号0
    ; AL=字符
    int 10h
    ret
print_char endp
```

#### 2.3.2 快速清屏技术
使用卷屏功能提高刷新效率:
```assembly
clear_screen_fast proc
    mov ax, 0600h       ; AH=06h(卷屏), AL=0(清空)
    mov bh, 07h         ; 黑底白字
    mov cx, 0100h       ; 左上角(1, 0)
    mov dx, 184Fh       ; 右下角(24, 79)
    int 10h             ; 执行清屏
    ret
clear_screen_fast endp
```

### 2.4 游戏速度控制

使用**双层循环延时**实现帧率控制:
```assembly
delay proc
    mov cx, 3           ; 外层循环3次
delay_outer:
    mov dx, 15000       ; 内层循环15000次
delay_inner:
    dec dx
    jnz delay_inner
    loop delay_outer
    ret
delay endp
```
总延时 = 外层循环次数 × 内层循环次数 = 3 × 15000 = 45000次循环

---

## 三、项目开发流程

### 3.1 开发步骤

本项目采用**自顶向下、逐步求精**的开发方法,按功能模块逐步实现:

**1. 需求分析与设计**

- 确定游戏核心玩法(双人对战Pong)
- 设计数据结构(球、球拍、分数等变量)
- 规划程序架构(主循环+子程序模块)
- 选择技术方案(文本模式、BIOS中断)

**2. 搭建基础框架**

- 编写程序骨架(.model, .stack, .data, .code)
- 实现初始化功能(视频模式、光标控制)
- 搭建游戏主循环框架
- 测试编译链接

**3. 实现各功能模块**
- **显示系统**: clear_screen、draw_game子程序
- **输入系统**: check_input子程序(非阻塞键盘检测)
- **物理引擎**: update_ball子程序(碰撞检测+得分判定)
- **速度控制**: delay子程序(双层循环延时)

**4. 测试与优化**
- 功能测试(移动、碰撞、计分)
- 兼容性测试(macOS/Windows DOSBox)
- 性能优化(调整游戏速度)
- 代码规范(添加注释、模块重构)

**5. 文档编写**

- 添加完整代码注释
- 编写项目说明文档
- 整理开发总结

### 3.2 关键问题解决

在开发过程中遇到并解决了以下问题:

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| macOS DOSBox黑屏 | VGA图形模式兼容性差 | 使用文本模式(80×25) |
| 游戏卡顿 | 阻塞式键盘等待 | 改用非阻塞检测(INT 16h功能01h) |
| 球穿透球拍 | 碰撞检测边界条件错误 | 修正Y坐标范围判断 |
| 跳转距离超限 | 条件跳转指令限制±127字节 | 使用就近标签+无条件跳转 |
| 游戏速度过快 | 延时循环次数太少 | 调整为双层循环(3×15000次) |

### 3.3 开发工具

**编译链接流程**:
```bash
# DOSBox中执行
masm pong.asm;      # 编译生成.obj
link pong.obj;      # 链接生成.exe
pong.exe            # 运行程序
```

**开发环境**:
- MASM 5.0 (Microsoft Macro Assembler)
- LINK 3.60 (Microsoft Overlay Linker)
- DOSBox 0.74-3 (DOS模拟器)

---

## 四、技术亮点

### 4.1 兼容性优化
- **文本模式实现**: 避免VGA图形模式在macOS DOSBox上的兼容性问题
- **非阻塞输入**: 使用INT 16h功能01h检测按键,保证游戏流畅运行
- **大小写兼容**: 通过`or al, 20h`统一处理大小写输入

### 4.2 代码优化
- **寄存器优化**: 合理使用AX、BX、CX、DX寄存器,减少内存访问
- **子程序设计**: 模块化设计,提高代码可读性和可维护性
- **边界检查**: 完善的边界条件判断,防止球拍移出屏幕

### 4.3 用户体验
- **实时响应**: 非阻塞输入保证按键即时响应
- **速度可调**: game_speed参数可根据不同电脑性能调整
- **视觉友好**: 使用ASCII 219实心块字符显示球拍,视觉效果清晰

---

## 五、使用说明

### 5.1 编译运行步骤

#### 在DOSBox中执行:
```bash
# 1. 挂载项目目录
mount c /Users/jack/work/Assembly_Language/Final_Program

# 2. 切换到C盘
c:

# 3. 编译源代码
masm pong.asm;

# 4. 链接生成可执行文件
link pong.obj;

# 5. 运行游戏
pong.exe
```

### 5.2 游戏操作说明

| 操作 | 按键 | 说明 |
|------|------|------|
| 玩家1向上 | W 或 w | 左侧球拍向上移动 |
| 玩家1向下 | S 或 s | 左侧球拍向下移动 |
| 玩家2向上 | I 或 i | 右侧球拍向上移动 |
| 玩家2向下 | K 或 k | 右侧球拍向下移动 |
| 退出游戏 | ESC | 任意时刻按ESC退出 |
| 开始游戏 | 任意键 | 游戏开始前按任意键 |

### 5.3 游戏规则
1. 双方各控制一个球拍(左侧/右侧)
2. 球在场地内来回弹跳
3. 用球拍接住球使其反弹
4. 球从对方一侧出界则得1分
5. 先得3分者获胜

### 5.4 参数调节

**调整游戏速度** (修改pong.asm):
```assembly
; 第32行: 调整内层循环次数
game_speed  dw 15000    ; 5000-20000(越大越慢)

; 第404行: 调整外层循环次数
mov cx, 3               ; 1-5(越大越慢)
```

**调整获胜分数**:
```assembly
; 第31行
win_score   db 3        ; 改为5、10等
```

---

## 六、项目总结与心得体会

### 6.1 项目完成情况

通过本次课程设计,我成功实现了一个完整的Pong双人对战游戏。项目基于8086汇编语言开发,使用MASM 5.0编译器在DOSBox环境下运行。游戏实现了球拍移动、球的运动、碰撞检测、计分系统等核心功能。最终的程序能够在macOS和Windows平台的DOSBox中稳定流畅地运行,达到了预期的设计目标。

在功能实现方面,游戏支持双人实时对战,玩家可以通过键盘控制各自的球拍进行游戏。碰撞检测采用了AABB算法,能够准确判断球与墙壁、球拍的碰撞。计分系统实时更新,当任意玩家达到3分时游戏结束并显示获胜者。为了解决macOS DOSBox的兼容性问题,我选择了文本模式而非VGA图形模式,这使得游戏具有更好的跨平台兼容性。

### 6.2 技术收获与体会

这次项目开发让我对汇编语言有了更深刻的理解。以前学习汇编时只是简单地了解指令格式和寄存器使用,但真正动手开发一个完整的程序后,才真正体会到汇编语言的特点和难点。

首先是对计算机底层工作原理的理解。在高级语言中,一个简单的变量赋值或函数调用都是理所当然的事情,但在汇编语言中,我需要考虑每个数据存放在哪个寄存器、如何在内存中布局数据、如何通过BIOS中断调用系统功能。这让我深刻认识到,我们平时使用的高级语言是建立在多么复杂的底层机制之上。

其次是对程序执行效率的认识。在实现游戏延时功能时,我最初使用的循环次数太少,导致游戏速度极快难以控制。通过不断调整和测试,我逐渐理解了循环指令的执行效率,以及如何通过嵌套循环来实现合适的延时。这个过程让我意识到,在底层编程中,每一条指令都会影响程序的性能。

再次是对调试能力的提升。汇编程序的调试比高级语言困难得多,因为没有方便的调试工具和错误提示。在开发过程中,我遇到了球穿透球拍、游戏卡顿、编译跳转超范围等各种问题。解决这些问题的过程让我学会了如何分析问题本质,如何通过修改代码逻辑来规避技术限制。特别是解决macOS兼容性问题时,我尝试了多种方案,最终选择了文本模式,这个决策过程让我明白了技术选型的重要性。

### 6.3 开发过程的困难与解决

开发过程中最大的困难是调试。由于汇编语言没有像Python或Java那样的友好错误提示,很多时候程序出错只会显示"程序异常终止"或者干脆黑屏。我不得不通过添加临时的显示语句、逐步注释代码块等方式来定位问题。这个过程虽然痛苦,但也让我养成了更加严谨的编程习惯——在写代码时就要考虑清楚每一步的逻辑,而不是依赖调试器。

另一个困难是跳转指令的距离限制。在实现键盘输入处理时,我使用了循环检测的结构,导致条件跳转指令的目标地址超出了±127字节的范围,编译器报错"Jump out of range"。解决这个问题花了我不少时间,最终通过重构代码逻辑、使用就近的跳转标签、必要时改用无条件跳转等方法才解决。这让我深刻理解了汇编语言的技术限制,也学会了如何在限制条件下设计程序结构。

### 6.4 学习心得

通过这次项目,我认识到汇编语言虽然开发效率低、代码难以维护,但它让我们能够直接操控硬件,理解程序的本质。这对于深入学习计算机科学非常重要。在现代软件开发中,我们很少直接使用汇编语言,但理解汇编的思想能帮助我们写出更高效的高级语言代码。

同时,我也体会到了模块化设计的重要性。即使在汇编语言中,通过合理划分子程序、设计清晰的接口,也能让代码结构更加清晰,便于调试和维护。这次项目中,我将功能划分为输入处理、物理更新、显示绘制等模块,每个模块相对独立,这大大降低了开发难度。

最后,这次项目让我认识到,学习编程不仅要学习语法和工具,更重要的是培养解决问题的能力。遇到问题时,要善于分析问题本质,查阅文档资料,尝试不同的解决方案。这种能力是通用的,无论使用什么编程语言都能用得上。

### 6.5 未来展望

虽然项目已经完成,但仍有一些可以改进的地方。例如,可以添加单人模式,实现简单的AI对手;可以增加难度选择功能,让玩家自定义球速和球拍大小;还可以利用PC喇叭实现简单的音效。这些功能如果有时间,我会在未来继续完善。

总的来说,这次汇编语言课程设计是一次非常宝贵的学习经历。它不仅让我掌握了汇编语言编程的基本技能,更重要的是培养了我解决问题的能力和编程思维。我相信这些收获将对我今后的学习和工作产生积极的影响。

---

**最后更新**: 2025年12月10日
